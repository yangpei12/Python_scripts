import matplotlib.pyplot as plt
import seaborn as sns
import networkx as nx
import pandas as pd
import numpy as np
import scipy
import os
os.chdir(r'C:\Users\lcbio\Desktop\工作\转录组开发计划\NLR免疫受体介导的植物免疫机制\基因集')


# ======== 1. 转录因子分析 ==========
""" 读取差异表达谱 """
diff_exp = pd.read_excel('rd_CKVSC_CK_Gene_differential_expression.xlsx')

""" 把和免疫相关的转录因子在表达谱中捞取出来 """
tfs = ['WRKY', 'MYB', 'bZIP', 'NAC', 'ERF', 'AP2']

tf_exp_df = diff_exp.query('(TF_Family == @tfs) & (significant == "yes")')

tf_exp_df_fpkm = tf_exp_df.filter(regex='gene_name|FPKM.')

new_col_name = tf_exp_df_fpkm.columns.str.replace('FPKM.', '')

tf_exp_df_fpkm.columns = new_col_name

""" 绘制热图 """
clustermap_data = pd.DataFrame(tf_exp_df_fpkm.iloc[:, 1:].values, 
                            columns=tf_exp_df_fpkm.columns[1:], 
                            index=tf_exp_df_fpkm['gene_name'])

sns.clustermap(
    clustermap_data,
    figsize=(7, 5),
    col_cluster=False,
    dendrogram_ratio=(.1, .2),
    cbar_pos=(0, .3, .03, .4)
)
plt.savefig('heatmap.png',dpi=600)


# ============= 转录因子相关性分析 ==================
# 模拟相关性
x = np.random.rand(10,30)
y = np.random.rand(30,30)

a_gene_matrxi = pd.DataFrame(x, index=['gene_a_' + str(x) for x in range(10)])
b_gene_matrxi = pd.DataFrame(y, index=['gene_b_' + str(x) for x in range(30)])

# 逐行扫描
corr_df = []
for m in range(a_gene_matrxi.shape[0]):
    x = a_gene_matrxi.iloc[m,:]
    x_name = a_gene_matrxi.index[m]
    for n in range(b_gene_matrxi.shape[0]):
        y = b_gene_matrxi.iloc[n,:]
        y_name = b_gene_matrxi.index[n]
        stat_pearson = scipy.stats.pearsonr(x, y)
        weight = round(stat_pearson[0],2)
        cor_df = pd.DataFrame({'source': x_name, 'target': y_name, 'weight':[weight]})
        corr_df.append(cor_df)
        # print(f'{x_name} and {y_name} corr is {stat_pearson[0]}')

edge_df = pd.concat(corr_df)

# 创建网络图对象
G = nx.DiGraph()

# 添加节点和边
for m in range(edge_df.shape[0]):
    source = edge_df.iloc[m,:][0]
    target = edge_df.iloc[m,:][1]
    weight = edge_df.iloc[m,:][2]
    G.add_edge(source, target, weight = weight)

# 提取权重
weights = np.array([G[u][v]['weight'] for u,v in G.edges()])

# 定义边的颜色（根据权重）
# edge_colors = ['red' if w > 0.5 else 'blue' for w in weights]

# 使用Viridis渐变色
cmap = plt.cm.viridis
norm = plt.Normalize(vmin=weights.min(), vmax=weights.max())
edge_colors = cmap(norm(weights))

# 绘制图
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_size=700, node_color= 'skyblue', font_size=10, edge_color = edge_colors)
# edge_labels = nx.get_edge_attributes(G, 'weight')
# nx.draw_networkx_edge_labels(G, pos)

# 添加颜色图例
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])
plt.colorbar(sm, label="Edge Correaltion")

# 生成交互式网络图
